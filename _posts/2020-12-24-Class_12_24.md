---
layout: post
title: 12月24日试卷讲评
date: 2020-12-24
categories: marginalia
tags: [课堂笔记]
description: 网课网课网课
header-img: "img/headline7.jpg"
catalog:  true
typora-root-url: ../../junyahuang.github.io
---

## C语言编程——模拟卷2讲评
<br>

### 纠错
预定义标识符:printf、scanf等，是可以作为自定义标识符的，但定义了之后，原先的预定义标识符的功能就消失了，只有变量的功能。


### 一、选择题
<br>

#### 第一题
#define N 10
- 符号常量： N代表10等等
- B:宏定义 -> #difne N 10，一个程序中可以多次使用

#### 第二题

- A：“HELLO\0”，6个元素
- B：char a[10];	a="China";是不合法的。
- C：“String!\0”，7个元素

#### 第三题

- x && 'B'<'b'
- 大写字母的ASCII码小于小写字母，所以'B'<'b'结果为true(1)
- 35 && 1 结果为true
- B赋值为1

#### 第四题

- sizeof()不是函数，是字节操作符，+-*=,返回一个unsight int
- 所以size of(double)整体是一个整型值，是一个整形表达式

#### 第五题

- 优先级：单目运算符>双目运算符>赋值运算符
- a的值不是一成不变的
- 遇到+=、-=等运算符先把他们改写



a += a -= a * a

a += → a = a +
a -= → a = a -

a = a + a = a - a * a

a = a + a = 3 - 9 → a = -6

a = -6 + -6 → a = -12

#### 第六题 

- A: double a=10是可以的，但是不能说double变量中存放了整形变量，10是要被强制转换成实型才能存进去的。

#### 第七题

- 整数以%xd格式"输出"的时候，如果超过了格式，只会往后推，不会把数字给砍掉（或者成为溢出）

- 但是scanf("%xd",&x)的输入格式又另当别论，以这个格式输入的时候，是会砍掉数字的，如scanf("%3d",x);输出1234，那x的值只剩下123了，4溢出。

#### 第八题

!a如果想运行，则!a不等于0，所以a等于0


#### 第九题

- i%2不等于0，也就是i为奇数时，i+'a'，如果i是1，那1+'a'就等于'b'

- 同理，i为偶数时，i+'A'，所以i为2时，2+'A'就等于'C'

- 所以答案是AbCdEf

#### 第十题

两个for循环。

第一次循环:
for(i=1)for(j=3,2,1)均不满足i*j>3
所以m有三次赋值，分别是m=3,m=2,m=1

第二次循环:
for(i=2)for(j=3,2,1)i=2,j=3的时候满足i*j>3，触发break，提前结束循环

随后i=3，不满足i<3，输出m=1，程序结束。


#### 第十一题

B: strlen返回字符串的长度，因为没有算\0，所以不是实际的大小
C: C语言中确实没有运算符
D: 新串少了第一个字符串的\0，所以新串的占用空间是会比原串少一些的
	例如：123\0 + 456\0 = 123456\0
strlen strcmp strcpy
"CHINA\0" 5 6 sizeof
C++ JAVA

#### 第十二题

A:	C语言中没有字符串数据类型，字符串只是一个特殊的字符数组
B: 数组str1包含s,t,r,l,\0五个元素
C: 如果没有\0，字符数组只有str1四个元素，没有\0的字符数组不是字符串
D: 字符数组不一定是字符串，所以不一定有\0，如
	char str[]={'C','H'}；则str数组的大小是2，只有C和H两个元素，是一个字符数组，但不是一个字符串，也不以\0结尾
	
#### 第十三题

- char *str1；str1是一个指针，也就是一个地址0x2134238 int 

- 地址就是一个十六进制数字，一般来说可以理解为地址是一个int型的数字

- 32位系统中(默认)，指针是4个字节，所以sizeof(str1)=sizeof(int)=4

#### 第十四题

- A: 外部定义的变量只对部分函数有效，比如如果使用函数时还没有定义变量，那变量就对这个函数无效了
- B: 函数内部的变量作用域在函数内部


#### 第十五题

简单的递归，递归结果是5+4+3+2+1=15

#### 第十六题

A: p是指针，&p就是指针的地址，是合法的
B: p是指针，*p就是指针所指向的数据
C: double *p, p+1就会挪动一个double的长度，double的长度为8
D: *p+1， *是单目运算符，+是双目运算符，优先级低于单目，所以先算 *p再算 
a[]={0,1}
p=a;
a={1,1}
a={0,1}

*p a++ b-- ++b 

+ - * /  a+b
		
		
#### 第十七题

- A: int **p是定义一个双重指针，指向一个指针的地址，详见课本指针那一章节的最后部分

- C: p=NULL p=0 p='\0'

- D:p=NULL执行后，指针p是一个“空”的状态，不指向任何地址，地址为0的存储单元是不能随便指向的。
- 在课本上有着相反的答案，据老师指出，课本上的描述是不合适的，以计算机等级考试的出题为准。

	
#### 第十八题

p在a[0]处，{5,&a[i]}，a->n则指向5，++5的值为6

#### 第十九题

B:函数可以返回一个结构体类型，结构体类型和其他类型没有太大的使用上的区别

#### 第二十题


- B:	*p.a，.为成员运算符，和[]等类似，优先级比单目运算符高，所以先执行p.a，p只是一个指针，不是结构体，所以p.a是不合法的


### 程序阅读题

#### 第一题

- &&和||都有“短路”的机制，++a||++b，前面的++a已经是1了，后面是1是0都无意义了，提前短路，所以++b是没有运行的。
- A?B:C的意思是，A如果是true(不等于0)，运行B，A如果是false等于0），运行C
- 所以结果是 1 0 1 0，最初的答案写成了1,0,1,0，那是我的笔误，格式必须要正确

#### 第二题

e = a + b++ - c * ++d
		4	+ 3 - 2	*	4
		7 - 8 = -1;
自加、自减运算符为单目运算符，优先级比双目运算符(+-*/)要高
- 先算b++，因为是b++，所以作为数值来用的时候，b依然是3保持不变
- 再算a + (b++) →	4 + 3 = 7
- 再算 7 - c，但是c后有 *，所以先算c * ++d
- ++d优先级更高，先算，结果是 d = 4
- 再算c * (++d) → 2 * 4 = 8
- 最后算 7 - 8 = -1
- 不要忘记了b之前有过++，所以b最后数值为4(有时候会提问b的值)



#### 第三题


一定要区分好形参和实参：

- fun(&m)，传入了m的地址，这个地址给了*s，所以s和m相等，但是s是一个形参，s的改变不会反过来影响m。
- 所以s=&k，此时s变成了k的地址，再进行 *s=k，相当于k=k
- 而最初的m是不会受到影响的，依旧是3。


#### 第四题

- 第一个while，当 *p 和 *a 不相等时，p的指针向右移动
- *p 和 *a 相等时，指针的位置在“y”处，strlen(a)=3
- p+=strlen(a)+1，p的指针向右移动4，you to Nenu → 移动到t
- 此时输出p后面的部分，输出to Nenu



#### 第五题

- 对a.name申请了一片动态空间，随后b=a时，其实是把a的动态空间(地址)赋给了b，此时a和b共用同一块空间，对b.name的修改等于对a.name的修改

- 所以 strcpy(b.name,"Qian")运行后，a.name的值也为"Qian"

- 遇到指针+动态空间的题，需要多谨慎。如果name定义时是一个数组，有一定的空间，那如果运行b=a，只会把a的值赋给b，此后对b的修改都不会影响到a。

- 指针因为没有自带的空间，需要利用动态空间，b=a时，是将一个该空间地址给了b，所以此后对b的修改是会影响到a的。




